from tkinter import *
import time

print('Imported success')
#Этот наш файлик, который мы подключаем в какой-либо проект
# Для наглядности,печатаем это)
# При импорте мы сможем пользоваться всем что располагается в этом файлике,
# в том числе и классами

#Тут все просто - создаем класс
# В данном случае это будет human)
class human(): #Вот так объявляется класс, тут собки должны быть пустыми
               #Вообще туда иногда можно и даже нужно передавать кое что
               #Но об этом не сейчас

    #Это базовый метод, __init__ - так называемый конструктор
    # Само название подсказывает для чего нужен этот метод =)
    # Тут есть один базовый аргумент - self
    # А дальше мы можем указывать любые параметры которые нам нужны

    # self - Это как бы сам экземпляр класса, который будет создан,
    # когда мы наш класс где-нибудь используем
    # например dima = human("dima", 26)
    #Тут мы создали "Экземпляр класса" human и передали туда два параметра
    #Конструктор класса human будет таким
    # __init__(self, name, age)
    def __init__(self, name, age):

        #Атрибуты класса практически то же самое, что обычные переменные
        # Только объявляются вот так
        # Тут мы объявдем атрибут name и присваеваем ему значение
        # которое будет передано
        self.name = name
        self.age = age

        #а тут мы просто создаем новую переменную
        self.birthday = "06.01.1994"
        #Эта переменная легко будет доступна из экземпляра класса
        # как для чтения так и для записи

        # Но что если я не хочу то бы кто то менял значения по умолчанию?
        # Например я точно уверен, что все любят фильм аватар
        # Так зачем же нам это менять?
        self.__bestFilm = 'AVATAR'
        #В питоне как я понял нельзя создать приватный атрибут класса,
        # Но двойное подчеркивание в начале названия значительно усложнит
        # изменение для неё. Так например получить значение теперь
        # Можно только через специальную функцию геттер,
        # которая будет возвращаться нам значение
    def getBestFilm(self):
        return self.__bestFilm
    # Методы мы создаем просто обычным способом,как функции
    # только первым аргументом всегда указываем self
    def sayHi(self):
        # Благодаря тому, что мы сохранили первоначальное значение, как атрибут
        # Мы теперь легко можем к нему обратиться
        print(f'Hi, my name is {self.name}')

        # так же мы можем ссылаться на свои же собственные функции
        # через self
        self.printBirthday()

    def printBirthday(self):
        print(f'I was born at {self.birthday}')





#
#     #------------------------------------------------------LESSON
#     # Тут я покажу как использовать наш класс,
#     # когда будет вызвана функция startGame
#     # Мы создадим меня)))
#
#     #Как видишь, тут только 2 аргумента, self пропускаем
#     # Если бы у нас в конструкторе был только self
#     # То тут вызывали бы так human()
# dima = human('Dima', 26)
#     # теперь dima - это экземпляр класса human и обладает всеми
#     # его методами и атрибутами
#
#     # Теперь я поздороваюсь
# print('ex N:____1')
# dima.sayHi()
# print('#------------------------------')
#
#     # Но что если мне нужно только имя?
#     # легко
# print('ex N:____2')
# print(dima.name)
# print('#------------------------------')
#
#     # Теперь создадим тебя
# leha = human('Alex', 14)
#
#     # Здоровайся
# print('ex N:____3')
# leha.sayHi()
# print('#------------------------------')
#     # Выведется
#     # Hi, my name is Alex
#     # I was born at 06.01.1994
#
#     # Стоп стоп стоп, это же не твоя дата рождения
#     # верно, тк дату рождения мы статично присваиваем в классе всем одинаковою
#     # но это не беда
# leha.birthday = "30.09.2006"
#
#     # Вот теперь скажи привет
# print('ex N:____4')
# leha.sayHi()
# print('#------------------------------')
#     # Теперь все гуд
#
#     # А что тамс любимым фильмом?
#     # print(leha.__bestFilm)
#     #Можешь расскоментироватьи попробовать - будет ошибка
#
#     #А вот так норм
# print('ex N:____5')
# print(leha.getBestFilm())
# print('#------------------------------')
#
#     # Конечно это не помешает нам сделать вот так
# leha.__bestFilm = 'Titanik'
# print('ex N:____6')
# print(leha.__bestFilm)
# print('#------------------------------')
#
#
#     # Но это не изменит внутреннее значение
#     # Поэтому когда мы захотим узнать
#     # Какой ты фильм любишь по настоящему
#     # Мы вызываем опять геттер и видим изначальный результат
# print('ex N:____7')
# print(leha.getBestFilm())
# print('#------------------------------')
#
#     # Может не очень понятно зачем защищать некоторые переменные или методы
#     # от перезаписи, попробую объяснить на примере
#     # Создадим ребенка,тк дети тоже люди воспользуемся уже готовым классом
# baby = human('Masha', 1)
#
#     # Маше всего 1 год, пусть поздоровается с нами
#     # Но мы помним, что дату рождения надо изменить
# baby.birthday = "01.01.2020"
# print('ex N:____8')
# baby.sayHi()
# print('#------------------------------')
#
#     # Вроде все ок, но как то слишком внятно она говорит для младенца
#     # Изменим это. Благодаря тому, что метод sayHi не защищен от перезаписи
#     # Мы легко можем это сделать
# baby.sayHi = lambda: print('agu agu agu')
# print('ex N:____9')
# baby.sayHi()
# print('#------------------------------')
#
#     # Так что любые незащащенные методы и атрибуты мы можем переписать.
#     # Это называется переопределить метод или перегрузить
#     # И если это большой проект,то мы можем и не знать
#     # переопределял метод кто то до нас или нет.
#     # Или какие то внутренние функции будут ссылаться на измененную функцию
#     # а она уже будет делать что то новое
#     # например вернемся ко мне
#     # и переопределим метод который печатает вторую строчку
# dima.printBirthday = lambda: print('bla bla bla')
#     # а теперь представь, что я в армии. Ко мне подходит генерал и говорит
#     # "Солдат, ты кто? Когда родился"
#     # А я отвечаю
# print('ex N:____10')
# dima.sayHi()
# print('#------------------------------')
#     # Упс, как не удобно получилось)
#     # Что бытаких моментов избегать как раз и надо защищать некоторые методы
#     # или атрибуты.
#     # А теперь попробуй в классе human изменить название метода на
#     # __printBirthday
#     # и тогда такой неловкой ситуации не будет)
#     # Вроде все

    #------------------------------------------------------LESSON





root = Tk()

timerShow = Label(root , text = '0')
timerShow.pack()

def stopt():
    a.stop()

def end(a):
    print('asd')

def but():
    a.start()
class timer():

    def __init__(self, widget, maxtime, endAct = None, endArgs = None):
        self.on = False

        self.maxtime = maxtime
        self.time = 0
        self.widget = widget
        self.endAct = endAct
        self.endArgs = endArgs
    def start(self):
        self.on = True
        if self.time < self.maxtime:
            self.time += 1
            self.widget['text'] = self.time
            self.check()
        else:
            self.endAct()
    def stop(self):
        self.on = False
    def check(self):
        if self.on == True:
            self.widget.after(1000, self.start)
# Я нашел где ты запутался)
# Пытаешься все делать в старте, но ведь старт должен только запускать
# И все)
# Попробуй разделить, обязанности - прилагаю картинку посмотри в папке
# Каждый прямуогольник с обычными углами это отдельный логический блок
# А вот пример прорисовки в фрейм
# def __init__(self, frame):
#     self.root = Frame
#     self.widget = Label(self.root, text = "00:00")


a = timer(timerShow,  30, end , 777 )
b = Button(text='start', command = but)
b.pack()


c = Button(text='stop', command = stopt)
c.pack()



root.mainloop()
